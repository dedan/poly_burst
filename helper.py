"""helper.py

        This file contains functions which might become handy or which are just needed to generate large amount of testing data. A lot of these functions deal with writting/reading polygons into or from files. In this case, polygons are not objects of class Poly from module poly_stim: they will be just data storing the information to generate objects of class Poly when necessary. 
        
        Seeking for the easiest way to store the information of a polygon, and taking into account that data is to be read from a file in a format such that it is easy to parse, the following convention is chosen (waiting for some feedback from Stefan!): 
            >> The data of a single polygon is stored as a set of numbers separated by ', ' (coma+single space). 
            >> Data from successive polygons is separated by a '\n' (EOL) symbol. 
            >> The first number indicates how many points a polygon has got. 
            >> The following numbers represent, alternativelly, the x- and the y-coordinate of each of the points. 
            >> The last four (three, whenever support for RGB exists) numbers indicate the color. 
            >> An example: 
                "3, 0., 0., 0.5, 0., 0., 0.5, 1., 1., 1., 1.\n"
                This string codes for a triangle (three points) with its vertices in (0., 0.) the first one, (0.5, 0.) the second one and (0., 0.5) the last one. It has got black color and is completely opaque. 
            >> The info of a polygon stored in such a format will be generically called 'pol'. 
            
        In agreement with Stephan, the module is modified to write/read polygons as json files. However, old functions (using old format) are kept by now and procedures are provided to translate from the old format to the new one. 
            
        At the end of the file a script is provided which generates 1000 such polygons. This is handy to store these polygons straight away in some file into the PolygonPool folder. 
        
    Functions: 
        newPol(): this functions generates the info necessary to write a new polygon. 
        newPoly(): this function creates an object of class Poly with the specifications provided. 
        normalizePol(): this function transforms the coordinates of a polygon living in a canvas with arbitrary measures into a canvas of size 1x1. 
        readPool(): this function reads all the polygons stored in a file and returns a list. 
        resizePol(): this function transforms the coordinates of a polygon living on a 1x1 canvas into one living on a canvas with arbitrary measures. 

        translatePol(): this functions takes the info of a polygon stored in the old format and translates it into a dictionary similar to those used by the '.json' module to store the data in files. 

        newPol_old(), newPoly_old(), normalizePol_old(), readPool_old(), resizePol_old(): same functions for the old format! 

"""

# Imports: 
import pickle, json; 
import numpy as np; 
import random as rnd; 
import copy; # See comment on resizePol() function. 
import poly_stim as ps; # This module is imported in case we wanted to generate actual objects of class Poly from here. 





####################################################################
## Newest functions (use the .json files to read info of polygons): 

def newPol(nPoints=None, points=None, color=None, minPoints=3, maxPoints=10): 
    """randPol function: 
    
        This function generates a new polygon with the specifications written in a dictionary. 
        The specifications can be provided. Whichever specification is not passed as an argument, it is generated by random. Thus, when calling the function without arguments a random polygon is created. 
        When random polygons are generated they live by default in a canvas of size 1x1, being (0., 0.) at the bottom left. The functions 'resizePol()' and 'normalizePol()' should tend a bridge between these polygons and polygons in any other canvas. 
        
    Arguments: 
        >> nPoints=None: number of points. In this implementation, this argument has interest only to specify the number of vertices that need to be created, if it is desired to specify this. 
        >> points=None: list with the points where the vertices of the polygon are set. Each points consist of a tuple giving the 'x' and the 'y' coordinates. In this implementation it is not necessary that 'nPoints==len(listPoints)' because 'nPoints' is not stored along with the other info. 
        >> color=None: tuple with the color of the polygon. Ideal would be that it could be either RGB or RGBA, but by now RGBA will be used, which incorporates more information. 
        >> minPoints=3: min number of vertices that a polygon is allowed to have. 
        >> maxPoints=10: max number of vertices that a polygon is allowed to have. 
        
    Returns: 
        << {'color':color, 'points':points}. 
    
    """
    
    # Setting up the number of points, if None: 
    if nPoints is None: 
        nPoints = rnd.randint(minPoints, maxPoints); 
        
    # Setting up the actual points, if None: 
    if points is None: 
        points=[]; 
        for n in range(nPoints): 
            points += [(rnd.random(), rnd.random())]; 
    
    # Setting up color, if None: 
    if color == None: 
        color = (rnd.random(), rnd.random(), rnd.random(), rnd.random()); 
        
    # Return a list with the different values: 
    return {'color':color, 'points':points}; 
    
def newPoly(pol, width=1., height=1., flagCenter=False): 
    """newPoly function: 
    
        This function generates a new object of class Poly with the info provided in 'pol', which is a dictionary as those read from a file. 
        
        The function also resizes the polygon by defect (this meaning that a polygon can be provided in a 1x1 canvas with the center in the bottom left and be resized to the required one). However, if no specifications are provided, the resizing does not do anything supposing that the info of the polygon is already in the desired system of coordinates. 
        
    Arguments: 
        >> pol: info to build the new Poly object. 
        >> width=1., height=1., flagCenter: info of the new coordinate system, if required. 
        
    Returns: 
        << Poly(values): object of class Poly initialized with 'values' which are specified by 'pol'. 
    
    """
    rPol = resizePol(pol, w=width, h=height, center=flagCenter); 
    
    return ps.Poly(color=rPol['color'], points=rPol['points']); 
    
def normalizePol(pol, h=1., w=1., center=False): 
    """renormalizePol function: 
   
        This function resizes a polygon which lives on a wxh canvas into a 1x1 canvas with the point (0., 0.) at the bottom left. 
        
        It operated over copies following what was necessary in the previous implementation, but I am not sure if this is necessary again. 
        
    Arguments: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        >> h=1.: the height of the old canvas. 
        >> w=1.: the width of the old canvas. 
        >> center=False: flag pointing out whether the point (0., 0.) is in the center of the old canvas (center=True) or not (center=False). 
        
    Returns: 
        << rPol: the info transformed in the proper way. 
    
    """
    
    # Copying for safety: 
    rPol = copy.copy(pol); 
    points = rPol['points']; 
    # Index over the points: 
    newPoints = []; 
    for point in points: 
        # Centering: 
        point0 = point[0]; 
        point1 = point[1]; 
        if center: 
            point0 += w/2; 
            point1 += h/2, 
        # Dividing by width and height: float is taken to avoid collapsing to 0 and 1: 
        point0 /= w; 
        point1 /= h; 
        newPoints += [(point0, point1)]; 
    rPol['points'] = newPoints; 
           
    # Return the transformed data:  
    return rPol; 
    
def readPool(folderPath='./PolygonPool', fileName='pPool.out', loadJson=True): 
    """readPool function: 
    
        This functions reads a file in which polygons were stored with the .json format and returns a list of the dictionaries containing the info of these polygons. 
        As implemented by Stephan Gabler, the polygon decomposition is stored in a list, being each element of the list the dictionary which corresponds to each polygon of the decomposition. 
        
    Arguments: 
        folderPath='./PolygonPool': path of the folder where the pool is stored. 
        fileName='pPool.out': name of the file with the pool of polygons. 
        
    Returns: 
        listPolygons: a list with dictionaries storing the specifications of the polygons. 
    
    """
    
    # DEBUG!! 
    
    # Reading data from the file: 
    if loadJson: 
        poolPath = folderPath+'/decomp.json'; 
    else: 
        poolPath = folderPath+'/'+fileName; 
    f = open(poolPath, 'r'); 
    
    if loadJson: 
        # Parsing with json: 
        listPolygons = json.loads(data); 
    else: 
        # Loading with pickle: 
        loadedPickler = pickle.Unpickler(f).load(); 
        listPolygons = loadedPickler.polies; 
    
    f.close(); 
    
    # Return: 
    return listPolygons; 
    
def resizePol(pol, h=1., w=1., pH=1., pW=1.): 
    """resizePol function: 
    
        This function resizes a polygon as given by Stephan Gabler's algorithm into the system of reference of the canvas. Stephan's outcome is a polygon which lives in a 1x1 space. The canvas where stimuli are drawn have size w times h (640x480) and the origin of coordinates is in the center. Therefore, the polygon must be resized and shifted left and down. 
        
    Arguments: 
        >> pol: a dictionary with the info of the polygon. 
        >> h=1.: the height of the new canvas. 
        >> w=1.: the width of the new canvas. 
        >> pH=1.: the height of the canvas where the polygonal decomposition was made. 
        >> pH=1.: the width of the canvas where the polygonal decomposition was made. 
        
    Returns: 
        << rPol: the info transformed in the proper way. 
    
    """
    
    # Copying for safety: 
    rPol = copy.copy(pol); 
    points = rPol['points']; 
    # Index over the points: 
    newPoints = []; 
    for point in points: 
        # Multiplying by width and height: 
        point0 = point[0]; 
        point1 = point[1]; 
        point0 *= w/pW; 
        point1 *= h/pH; 
        point0 -= w/2; 
        point1 -= h/2; 
        newPoints += [(point0, point1)]; 
    rPol['points'] = newPoints; 
           
    # Return the transformed data:  
    return rPol; 
    

####################################################################
## Translate functions (from old --lists-- to new --.json-- format): 

    
def translatePol(oldPol): 
    """translatePol function: 
    
        This function takes the info to build a polygon in the format specified at the beginning of the file and returns a dictionary similar to those stored in files by means of the .json module. 
        
    Arguments: 
        >> oldPol: info to build a polygon stored in the format described above. 
        
    Returns: 
        << newPol: dictionary with the info of the polygon passed in the argument. 
    
    """
    
    pRange = range(oldPol[0]); 
    points = []; 
    for pp in pRange: 
        points += [(oldPol[2*pp+1], oldPol[2*pp+2])]; 
    color = (oldPol[len(oldPol)-4], oldPol[len(oldPol)-3], oldPol[len(oldPol)-2], oldPol[len(oldPol)-1]); 
    
    # To return: 
    newPol = {'color':color, 'points':points}; 
    return newPol; 


####################################################################
## Old functions (manage polygons info in the old format): 


def newPol_old(nPoints=None, listPoints=None, minPoints=3, maxPoints=10, color=None): 
    """randPol function: 
    
        This function generates a new polygon. Its specifications can be provided. Whichever specification is not passed as an argument, it is generated by random. Thus, when calling the function without arguments a random polygon is created. 
        When random polygons are generated they live by default in a canvas of size 1x1, being (0., 0.) at the bottom left. The functions 'resizePol()' and 'normalizePol()' should tend a bridge between these polygons and polygons in any other canvas. 
        
    Arguments: 
        >> nPoints=None: number of points. 
        >> listPoints=None: points where the vertices of the polygon are set. It must be assert that 'nPoints==listPoints', else an error is raised. 
        >> minPoints=3: min number of vertices that a polygon is allowed to have. 
        >> maxPoints=10: max number of vertices that a polygon is allowed to have. 
        >> color=None: color of the polygon. Ideal would be that it could be either RGB or RGBA, but by now RGBA will be used, which incorporates more information. 
        
    Returns: 
        << [nPoints]+listPoints+color: a list with all the necessary info to construct a new polygon as specified at the beginning of the file. 
    
    """
    
    # Setting up the number of points, if None: 
    if nPoints is None: 
        nPoints = rnd.randint(minPoints, maxPoints); 
        
    # Setting up the actual points, if None: 
    if listPoints is None: 
        listPoints=[]; 
        for n in range(nPoints): 
            listPoints += [rnd.random(), rnd.random()]; 
            
    # Asserting that actual number of points agrees with 'nPoints': 
    assert(2*nPoints==len(listPoints)); 
    
    # Setting up color, if None: 
    if color == None: 
        color = [rnd.random(), rnd.random(), rnd.random(), rnd.random()]; 
        
    # Return a list with the different values: 
    return [nPoints] + listPoints + color; 
    
def newPoly_old(pol, width, height, flagCenter): 
    """newPoly function: 
    
        This function generates a new object of class Poly with the info provided in 'pol'. 
        
    Arguments: 
        >> pol: info to build the new Poly object. 
        
    Returns: 
        << Poly(values): object of class Poly initialized with 'values' which are specified by 'pol'. 
    
    """
    rPol = resizePol(pol, w=width, h=height, center=flagCenter); 
    newColor, newPoints = translatePol(rPol); 
    
    return ps.Poly(color = newColor, 
                   orientation = 0.0,
                   points = newPoints, 
                   position = (width/2, height/2),
                   line_width = 3); 

def normalizePol_old(pol, h=1., w=1., center=False): 
    """rnormalizePol function: 
   
        This function resizes a polygon which lives on a wxh canvas into a 1x1 canvas with the point (0., 0.) at the bottom left. 
        
        It is necessary to operate over copies of the original points! If not, the operations are applied several times to the same polygons and the result does not make any sense. 
        
    Arguments: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        >> h=1.: the height of the old canvas. 
        >> w=1.: the width of the old canvas. 
        >> center=False: flag pointing out whether the point (0., 0.) is in the center of the old canvas (center=True) or not (center=False). 
        
    Returns: 
        << rPol: the info transformed in the proper way. 
    
    """
    
    # An index to run over the points of 'pol': 
    rPol = copy.copy(rPol); 
    pRange = range(rPol[0]); 
    for pp in pRange: 
        # Centering: 
        if center: 
            rPol[2*pp+1] += w/2; 
            rPol[2*pp+2] += h/2, 
        # Dividing by width and height: float is taken to avoid collapsing to 0 and 1: 
        rPol[2*pp+1] = float(rPol[2*pp+1])/w; 
        rPol[2*pp+2] = float(rPol[2*pp+2])/h; 
           
    # Return the transformed data:  
    return rPol; 
    
def readPool_old(folderPath='./PolygonPool', fileName='pPool.out'): 
    """readPool function: 
    
        This functions reads a file in which polygons were stored with the format described above and returns a list of such polygons. 
        
    Arguments: 
        folderPath='./PolygonPool': path of the folder where the pool is stored. 
        fileName='pPool.out': name of the file with the pool of polygons. 
        
    Returns: 
        listPolygons: a list with polygons stored in the proper format. 
    
    """
    
    # Reading data from the file: 
    poolPath = folderPath+'/'+fileName; 
    f = open(poolPath, 'r'); 
    pListStrings = f.read().split('\n'); 
    pListStrings.pop(); 
    f.close(); 
    
    # Transforming strings into numbers: 
    listPolygons = []; 
    for pString in pListStrings: 
        newPolStrings = pString.split(', '); 
        newPol = []; 
        flag0 = True; 
        for vString in newPolStrings: 
            if flag0: 
                # Size is always integer (if not, problems to generate ranges). 
                newPol += [int(vString)]; 
                flag0 = False; 
            else: 
                newPol += [float(vString)]; 
        listPolygons += [newPol]; 
        
    return listPolygons; 
    
def resizePol_old(pol, h=1., w=1., center=False): 
    """resizePol function: 
    
        This function resizes a polygon which lives on a 1x1 canvas with the point (0., 0.) at the bottom left into a canvas of arbitrary height and width which might have the point (0., 0.) at the center or not. If called only with the obligatory arguments, this function does not operate any change in the data. 
        
        It is necessary to operate over copies of the original points! If not, the operations are applied several times to the same polygons and the result does not make any sense. 
        
    Arguments: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        >> h=1.: the height of the new canvas. 
        >> w=1.: the width of the new canvas. 
        >> center=False: flag pointing out whether the point (0., 0.) is to be in the center of the new canvas (center=True) or not (center=False). 
        
    Returns: 
        << rPol: the info transformed in the proper way. 
    
    """
    
    # An index to run over the points of 'pol': 
    rPol = copy.copy(pol); 
    pRange = range(rPol[0]); 
    for pp in pRange: 
        # Multiplying by width and height: 
        rPol[2*pp+1] = w*rPol[2*pp+1]; 
        rPol[2*pp+2] = h*rPol[2*pp+2]; 
        # Centering: 
        if center: 
            rPol[2*pp+1] -= w/2; 
            rPol[2*pp+2] -= h/2; 
           
    # Return the transformed data:  
    return rPol; 
    
def flipX(pol): 
    """flipX function: 
    
        This function flips the polygon over the x axis. 
        
    Attributes: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        
    Returns: 
        << rPol: the info transformed in the proper way. 
    
    """
    
    rPol = copy.copy(pol); 
    points = rPol['points']; 
    newPoints = []; 
    for pp in points: 
        # Flip: 
        newPoints += [(-pp[0], pp[1])]; 
    rPol['points'] = newPoints; 
        
    return rPol; 
    
def flipY(pol): 
    """flipY function: 
    
        This function flips the polygon over the y axis. 
        
    Attributes: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        
    Returns: 
        << rPol: the info transformed in the proper way. 
    
    """
    
    rPol = copy.copy(pol); 
    points = rPol['points']; 
    newPoints = []; 
    for pp in points: 
        # Flip: 
        newPoints += [(pp[0], -pp[1])]; 
    rPol['points'] = newPoints; 
        
    return rPol; 

    
def getRandomPath(path): 
    """ getRandomPath function: 

    This function returns the path of a file chosen by random from the folder 'path'. 

    Attributes: 
    >> path: string variable with the path of the folder. 

    Returns: 
        << filePath: string variable with the path of the file chosen by random. 

    """
    
    filePath = rnd.choice(os.listdir(path)); 
    return filePath; 


    

if __name__=='__main__': 
    for ii in range(1000): 
        nPolStr = json.dumps(newJsonPol()); 
        print nPolStr; 











