"""helper.py

    This file contains functions which might become handy or which are just
    needed to generate large amount of testing data. A lot of these functions
    deal with writting/reading polygons into or from files. In this case,
    polygons are not objects of class Poly from module poly_stim: they will
    be just data storing the information to generate objects of class Poly
    when necessary. This information is serialized using the json format.

"""

import pickle, json, os
import numpy as np
import random as rnd
import copy
import poly_stim as ps


def newPol(nPoints=None, points=None, color=None, minPoints=3, maxPoints=10):
    """randPol function:

        This function generates a new polygon with the specifications written
        in a dictionary. The specifications can be provided. Whichever specification
        is not passed as an argument, it is generated by random. Thus, when
        calling the function without arguments a random polygon is created.
        When random polygons are generated they live by default in a canvas
        of size 1x1, being (0., 0.) at the bottom left. The functions 'resizePol()'
        and 'normalizePol()' should tend a bridge between these polygons
        and polygons in any other canvas.

    Arguments:
        nPoints=None: number of vertices
        points=None: list with the points where the vertices of the polygon are set.
            Each points consist of a tuple giving the 'x' and the 'y' coordinates.
            In this implementation it is not necessary that 'nPoints==len(listPoints)'
            because 'nPoints' is not stored along with the other info.
        color=None: tuple with the color of the polygon. (RGBA)
        minPoints=3: min number of vertices that a polygon is allowed to have.
        maxPoints=10: max number of vertices that a polygon is allowed to have.

    Returns:
        {'color':color, 'points':points}.
    """

    # Setting up the number of points, if None:
    if nPoints is None:
        nPoints = rnd.randint(minPoints, maxPoints);

    # Setting up the actual points, if None:
    if points is None:
        points=[];
        for n in range(nPoints):
            points += [(rnd.random(), rnd.random())];

    # Setting up color, if None:
    if color == None:
        color = (rnd.random(), rnd.random(), rnd.random(), rnd.random());

    return {'color':color, 'points':points};


def newPoly(pol, width=1., height=1., flagCenter=False):
    """newPoly function:

        This function generates a new object of class Poly with the info provided
        in 'pol', which is a dictionary as those read from a file.

        The function also resizes the polygon by default (this meaning that a
        polygon can be provided in a 1x1 canvas with the center in the bottom
        left and be resized to the required one). However, if no specifications
        are provided, the resizing does not do anything supposing that the info
        of the polygon is already in the desired system of coordinates.

    Arguments:
        pol: info to build the new Poly object.
        width=1., height=1., flagCenter: info of the new coordinate system, if required.

    Returns:
        Poly(values): object of class Poly initialized with 'values' which are specified by 'pol'.

    """
    rPol = resizePol(pol, w=width, h=height, center=flagCenter);
    return ps.Poly(color=rPol['color'], points=rPol['points']);


def normalizePol(pol, h=1., w=1., center=False):
    """renormalizePol function:

        This function resizes a polygon which lives on a wxh canvas into a 1x1
        canvas with the point (0., 0.) at the bottom left.

        It operated over copies following what was necessary in the previous
        implementation, but I am not sure if this is necessary again.

    Arguments:
        pol: the info of the polygon on which the function is supposed to operate.
        h=1.: the height of the old canvas.
        w=1.: the width of the old canvas.
        center=False: flag pointing out whether the point (0., 0.) is in the center of the old canvas (center=True) or not (center=False).

    Returns:
        rPol: the info transformed in the proper way.
    """

    # Copying for safety:
    rPol = copy.copy(pol);
    points = rPol['points'];
    # Index over the points:
    newPoints = [];
    for point in points:
        # Centering:
        point0 = point[0];
        point1 = point[1];
        if center:
            point0 += w/2;
            point1 += h/2,
        # Dividing by width and height: float is taken to avoid collapsing to 0 and 1:
        point0 /= w;
        point1 /= h;
        newPoints += [(point0, point1)];
    rPol['points'] = newPoints;
    return rPol;


def readPool(folderPath='./PolygonPool', fileName='pPool.out', loadJson=True, loadTriangle=False):
    """readPool function:

        This functions reads a file in which polygons were stored with the .json
        format and returns a list of the dictionaries containing the info of
        these polygons. As implemented by Stephan Gabler, the polygon decomposition
        is stored in a list, being each element of the list the dictionary which
        corresponds to each polygon of the decomposition.

    Arguments:
        folderPath='./PolygonPool': path of the folder where the pool is stored.
        fileName='pPool.out': name of the file with the pool of polygons.

    Returns:
        listPolygons: a list with dictionaries storing the specifications of the polygons.

    """

    # Reading data from the file:
    if loadJson:
        poolPath = os.path.join(folderPath, 'polies.json');
        if loadTriangle:
            poolPath = os.path.join(folderPath, 'polies_.json');
    else:
        poolPath = os.path.join(folderPath, fileName);

    with open(poolPath, 'r') as f:
        if loadJson:
            # Parsing with json:
            listPolygons = json.load(f);
        else:
            # Loading with pickle:
            loadedPickler = pickle.Unpickler(f).load();
            listPolygons = loadedPickler.polies;

    return listPolygons;


def resizePol(pol, h=1., w=1., pH=1., pW=1.):
    """resizePol function:

        This function resizes a polygon as given by Stephan Gabler's algorithm
        into the system of reference of the canvas. Stephan's outcome is a polygon
        which lives in a 1x1 space. The canvas where stimuli are drawn have
        size w times h (640x480) and the origin of coordinates is in the center.
        Therefore, the polygon must be resized and shifted left and down.

    Arguments:
        pol: a dictionary with the info of the polygon.
        h=1.: the height of the new canvas.
        w=1.: the width of the new canvas.
        pH=1.: the height of the canvas where the polygonal decomposition was made.
        pH=1.: the width of the canvas where the polygonal decomposition was made.

    Returns:
        rPol: the info transformed in the proper way.
    """

    # Copying for safety:
    rPol = copy.copy(pol);
    points = rPol['points'];
    # Index over the points:
    newPoints = [];
    for point in points:
        # Multiplying by width and height:
        point0 = point[0];
        point1 = point[1];
        point0 *= w/pW;
        point1 *= h/pH;
        point0 -= w/2;
        point1 -= h/2;
        newPoints += [(point0, point1)];
    rPol['points'] = newPoints;
    return rPol;


def slidePoints(pol):
    """slidePoints function:

        This funtion is implemented to try something out: In the current state
        of the affairs the polygons seem to fold in when they are concave. Which
        part they show as a folding might depend on the order in which the points
        are given, therefore it is tried out to slide the order of the points
        to test if this solves the problem.
    """

    rPol = copy.copy(pol);
    points = rPol['points'];
    points_ = [points[-1]]+points[0:len(points)-1];
    rPol['points'] = points_;
    return rPol;


def flipX(pol):
    """flipX function:

        This function flips the polygon over the x axis.
    """

    rPol = copy.copy(pol);
    points = rPol['points'];
    newPoints = [];
    for pp in points:
        # Flip:
        newPoints += [(-pp[0], pp[1])];
    rPol['points'] = newPoints;
    return rPol;


def flipY(pol):
    """flipY function:

        This function flips the polygon over the y axis.
    """

    rPol = copy.copy(pol);
    points = [];
    for ii in range(len(rPol['points'])):
        points += [rPol['points'].pop()];
    newPoints = [];
    for pp in points:
        # Flip:
        newPoints += [(pp[0], -pp[1])];
    rPol['points'] = newPoints;
    return rPol;


if __name__=='__main__':
    for ii in range(1000):
        nPolStr = json.dumps(newJsonPol());
        print nPolStr;











