"""helper.py

        This file contains functions which might become handy or which are just needed to generate large amount of testing data. A lot of these functions deal with writting/reading polygons into or from files. In this case, polygons are not objects of class Poly from module poly_stim: they will be just data storing the information to generate objects of class Poly when necessary. 
        
        Seeking for the easiest way to store the information of a polygon, and taking into account that data is to be read from a file in a format such that it is easy to parse, the following convention is chosen (waiting for some feedback from Stefan!): 
            >> The data of a single polygon is stored as a set of numbers separated by ', ' (coma+single space). 
            >> Data from successive polygons is separated by a '\n' (EOL) symbol. 
            >> The first number indicates how many points a polygon has got. 
            >> The following numbers represent, alternativelly, the x- and the y-coordinate of each of the points. 
            >> The last four (three, whenever support for RGB exists) numbers indicate the color. 
            >> An example: 
                "3, 0., 0., 0.5, 0., 0., 0.5, 1., 1., 1., 1.\n"
                This string codes for a triangle (three points) with its vertices in (0., 0.) the first one, (0.5, 0.) the second one and (0., 0.5) the last one. It has got black color and is completely opaque. 
            >> The info of a polygon stored in such a format will be generically called 'pol'. 
            
        At the end of the file a script is provided which generates 1000 such polygons. This is handy to store these polygons straight away in some file into the PolygonPool folder. 
        
    Functions: 
        newPol(): this functions generates the info necessary to write a new polygon. 
        resizePol(): this function transforms the coordinates of a polygon living on a 1x1 canvas into one living on a canvas with arbitrary measures. 
        normalizePol(): this function transforms the coordinates of a polygon living in a canvas with arbitrary measures into a canvas of size 1x1. 
        readPool(): this function reads all the polygons stored in a file and returns a list. 
        translatePol(): this functions takes the info of a polygon stored in the previously explained format and translates it into the arguments necessary to generate objects of class Poly. 

"""

# Imports: 
import numpy as np; 
import random as rnd; 
import poly_stim as ps; # This module is imported in case we wanted to generate actual objects of class Poly from here. 


def newPol(nPoints=None, listPoints=None, minPoints=3, maxPoints=10, color=None): 
    """randPol function: 
    
        This function generates a new polygon. Its specifications can be provided. Whichever specification is not passed as an argument, it is generated by random. Thus, when calling the function without arguments a random polygon is created. 
        When random polygons are generated they live by default in a canvas of size 1x1, being (0., 0.) at the bottom left. The functions 'resizePol()' and 'normalizePol()' should tend a bridge between these polygons and polygons in any other canvas. 
        
    Arguments: 
        >> nPoints=None: number of points. 
        >> listPoints=None: points where the vertices of the polygon are set. It must be assert that 'nPoints==listPoints', else an error is raised. 
        >> minPoints=3: min number of vertices that a polygon is allowed to have. 
        >> maxPoints=10: max number of vertices that a polygon is allowed to have. 
        >> color=None: color of the polygon. Ideal would be that it could be either RGB or RGBA, but by now RGBA will be used, which incorporates more information. 
        
    Returns: 
        << [nPoints]+listPoints+color: a list with all the necessary info to construct a new polygon as specified at the beginning of the file. 
    
    """
    
    # Setting up the number of points, if None: 
    if nPoints is None: 
        nPoints = rnd.randint(minPoints, maxPoints); 
        
    # Setting up the actual points, if None: 
    if listPoints is None: 
        listPoints=[]; 
        for n in range(nPoints): 
            listPoints += [rnd.random(), rnd.random()]; 
            
    # Asserting that actual number of points agrees with 'nPoints': 
    assert(2*nPoints==len(listPoints)); 
    
    # Setting up color, if None: 
    if color == None: 
        color = [rnd.random(), rnd.random(), rnd.random(), rnd.random()]; 
        
    # Return a list with the different values: 
    return [nPoints] + listPoints + color; 


def resizePol(pol, h=1., w=1., center=False): 
    """resizePol function: 
    
        This function resizes a polygon which lives on a 1x1 canvas with the point (0., 0.) at the bottom left into a canvas of arbitrary height and width which might have the point (0., 0.) at the center or not. If called only with the obligatory arguments, this function does not operate any change in the data. 
        
    Arguments: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        >> h=1.: the height of the new canvas. 
        >> w=1.: the width of the new canvas. 
        >> center=False: flag pointing out whether the point (0., 0.) is to be in the center of the new canvas (center=True) or not (center=False). 
        
    Returns: 
        << pol: the info transformed in the proper way. 
    
    """
    
    # An index to run over the points of 'pol': 
    pRange = range(pol[0]); 
    for pp in pRange: 
        # Multiplying by width and height: 
        pol[2*pp+1] = w*pol[2*pp+1]; 
        pol[2*pp+2] = h*pol[2*pp+2]; 
        # Centering: 
        if center: 
            pol[2*pp+1] -= w/2; 
            pol[2*pp+2] -= h/2; 
           
    # Return the transformed data:  
    return pol; 
    
    
def normalizePol(pol, h=1., w=1., center=False): 
    """rnormalizePol function: 
   
        This function resizes a polygon which lives on a wxh canvas into a 1x1 canvas with the point (0., 0.) at the bottom left. 
        
    Arguments: 
        >> pol: the info of the polygon on which the function is supposed to operate. 
        >> h=1.: the height of the old canvas. 
        >> w=1.: the width of the old canvas. 
        >> center=False: flag pointing out whether the point (0., 0.) is in the center of the old canvas (center=True) or not (center=False). 
        
    Returns: 
        << pol: the info transformed in the proper way. 
    
    """
    
    # An index to run over the points of 'pol': 
    pRange = range(pol[0]); 
    for pp in pRange: 
        # Centering: 
        if center: 
            pol[2*pp+1] += w/2; 
            pol[2*pp+2] += h/2, 
        # Dividing by width and height: float is taken to avoid collapsing to 0 and 1: 
        pol[2*pp+1] = float(pol[2*pp+1])/w; 
        pol[2*pp+2] = float(pol[2*pp+2])/h; 
           
    # Return the transformed data:  
    return pol; 
    
def readPool(folderPath='./PolygonPool', fileName='pPool.out'): 
    """readPool function: 
    
        This functions reads a file in which polygons were stored with the format described above and returns a list of such polygons. 
        
    Arguments: 
        folderPath='./PolygonPool': path of the folder where the pool is stored. 
        fileName='pPool.out': name of the file with the pool of polygons. 
        
    Returns: 
        listPolygons: a list with polygons stored in the proper format. 
    
    """
    
    # Reading data from the file: 
    poolPath = folderPath+'/'+fileName; 
    f = open(poolPath, 'r'); 
    pListStrings = f.read().split('\n'); 
    pListStrings.pop(); 
    f.close(); 
    
    # Transforming strings into numbers: 
    listPolygons = []; 
    for pString in pListStrings: 
        newPolStrings = pString.split(', '); 
        newPol = []; 
        flag0 = True; 
        for vString in newPolStrings: 
            if flag0: 
                # Size is always integer (if not, problems to generate ranges). 
                newPol += [int(vString)]; 
                flag0 = False; 
            else: 
                newPol += [float(vString)]; 
        listPolygons += [newPol]; 
        
    return listPolygons; 
    

def newPoly(pol, width, height, flagCenter): 
    """newPoly function: 
    
        This function generates a new object of class Poly with the info provided in 'pol'. 
        
    Arguments: 
        >> pol: info to build the new Poly object. 
        
    Returns: 
        << Poly(values): object of class Poly initialized with 'values' which are specified by 'pol'. 
    
    """
    rPol = resizePol(pol, w=width, h=height, center=flagCenter); 
    newColor, newPoints = translatePol(rPol); 
    
    return ps.Poly(color = newColor, 
                   orientation = 0.0,
                   points = newPoints, 
                   position = (width/2, height/2),
                   line_width = 3); 
    
    
def translatePol(pol): 
    """translatePol function: 
    
        This function takes the info to build a polygon in the format specified at the beginning of the file and returns the arguments to build an object of class Poly. Further specifications (such as position or line with) is to be provided from outside. 
        
    Arguments: 
        >> pol: info to build a polygon stored in the format described above. 
        
    Returns: 
        << color: color of the polygons. 
        << listPoints: list with the coordinates of the successive points. 
    
    """
    
    pRange = range(pol[0]); 
    listPoints = []; 
    for pp in pRange: 
        listPoints += [(pol[2*pp+1], pol[2*pp+2])]; 
    color = (pol[len(pol)-4], pol[len(pol)-3], pol[len(pol)-2], pol[len(pol)-1]); 
    return color, listPoints; 
    

if __name__=='__main__': 
    for ii in range(1000): 
        nPolStr = str(newPol()); 
        print nPolStr[1:len(nPolStr)-1]; 











